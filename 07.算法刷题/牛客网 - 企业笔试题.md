# 牛客网历年企业笔试题

## 字节跳动

### 字节跳动2018校招前端方向（第二批） [传送门](https://www.nowcoder.com/test/8537237/summary)

#### 用户喜好

```txt
为了不断优化推荐效果，今日头条每天要存储和处理海量数据。
假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，
我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。
因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1<=L2<=R2<=R1)。

输入描述：
输入：
第1行为n代表用户的个数
第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度
第3行为一个正整数q代表查询的组数
第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l<=i<=r的用户中对这类文章喜好值为k的用户的个数。
数据范围n <= 300000,q<=300000 k是整型

输出描述:
输出：一共q行，每行一个整数代表喜好值为k的用户的个数

示例：

输入：
5
1 2 3 3 5
3
1 2 1
2 4 5
3 5 3

输出：
1
0
2

说明：
样例解释:
有5个用户，喜好值为分别为1、2、3、3、5，
第一组询问对于标号[1,2]的用户喜好值为1的用户的个数是1
第二组询问对于标号[2,4]的用户喜好值为5的用户的个数是0
第三组询问对于标号[3,5]的用户喜好值为3的用户的个数是2
```

```js
let n = parseInt(readline());
let arr = readline().split(' ').map(e => Number(e));
let q = parseInt(readline());
let xihaodu = [];
while(q>0){
  q--;
  xihaodu.push(readline().split(' ').map(e => Number(e)));
}
let res = [];
arr.forEach((item, index) => {
    if (res[item] == undefined){
        res[item]=[];
    }
    res[item].push(index);
})
xihaodu.forEach((item, index) => {
    let [l, r, k] = item;
    let count = 0;
    if (res[k] == undefined) {
        console.log(0)
    }else {
        res[k].forEach(e => {
            if (e>=l-1 && e<=r-1) {
                count++;
            }
        })
        print(count)
    }
})
```

#### 手串

```txt
作为一个手串艺人，有金主向你订购了一条包含n个杂色串珠的手串——每个串珠要么无色，要么涂了若干种颜色。
为了使手串的色彩看起来不那么单调，金主要求，手串上的任意一种颜色（不包含无色），在任意连续的m个串珠里至多出现一次（注意这里手串是一个环形）。
手串上的颜色一共有c种。现在按顺时针序告诉你n个串珠的手串上，每个串珠用所包含的颜色分别有哪些。
请你判断该手串上有多少种颜色不符合要求。即询问有多少种颜色在任意连续m个串珠中出现了至少两次。

输入描述:
第一行输入n，m，c三个数，用空格隔开。(1 <= n <= 10000, 1 <= m <= 1000, 1 <= c <= 50) 
接下来n行每行的第一个数num_i(0 <= num_i <= c)表示第i颗珠子有多少种颜色。
接下来依次读入num_i个数字，每个数字x表示第i颗柱子上包含第x种颜色(1 <= x <= c)

输出描述:
一个非负整数，表示该手链上有多少种颜色不符需求。

示例1

输入
5 2 3
3 1 2 3
0
2 2 3
1 2
1 3

输出
2

说明
第一种颜色出现在第1颗串珠，与规则无冲突。
第二种颜色分别出现在第 1，3，4颗串珠，第3颗与第4颗串珠相邻，所以不合要求。
第三种颜色分别出现在第1，3，5颗串珠，第5颗串珠的下一个是第1颗，所以不合要求。
总计有2种颜色的分布是有问题的。
这里第2颗串珠是透明的。
```

```js
let [n, m, c] = readline().trim().split(' ').map(e => parseInt(e));
let arr = [];
for (let i=0;i<n;i++){
  arr.push(readline().split(' ').map(e => parseInt(e)));
}
let res = [];
arr.forEach((item, index) => {
  if (item[0] > 0) {
    item.slice(1).forEach(e => {
      if(res[e]) {
        res[e].push(index+1);
      }else {
        res[e] = [index + 1];
      }
    })
  }
})
let count = 0;
res.forEach(item => {
  for(let i=0;i<item.length-1;i++){
    if(item[i+1]-item[i]<m){
      count++
      break;
    }
    if(item[0]-item[item.length-1]+n<m){ //因为手链是个环，所以最后一个要跟第一个做一下比较
      count++;
      break;
    }
  }
})
print(count)
```

### 字节跳动编程真题 [传送门](https://www.nowcoder.com/ta/exam-bytedance)

#### ZJ1 附加题

```txt
题目描述
存在n+1个房间，每个房间依次为房间1 2 3...i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1<=pi<=i),
现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：
    A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；
    B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；
现在路人甲想知道移动到房间n+1一共需要多少次移动；

输入描述:
第一行包括一个数字n(30%数据1<=n<=100，100%数据 1<=n<=1000)，表示房间的数量，
接下来一行存在n个数字 pi(1<=pi<=i), pi表示从房间i可以传送到房间pi。

输出描述:
输出一行数字，表示最终移动的次数，最终结果需要对1000000007 (10e9 + 7) 取模。

示例1

输入
2
1 2

输出
4

说明
开始从房间1 只访问一次所以只能跳到p1即 房间1， 之后采用策略A跳到房间2，房间2这时访问了一次因此采用策略B跳到房间2，
之后采用策略A跳到房间3，因此到达房间3需要 4 步操作。
```

> 题解：

- 仔细分析 1<=pi<=i 知道用动态规划做。
- 记录第一次到达i为dp[i]，此时前面的所有门肯定是已经到达偶数次了
  - 因为传送只会后退，前进的唯一方式是偶数次到达并+1，不能跳跃
  - 所以到达i门前面所有门都走过并且经过偶数次（反正法也可以证明）
- dp[i]=dp[i-1]+第二次到达i-1 + 1
- 第一次到达i-1门后再走一步会回到p[i-1]，此时p[i-1]门到达奇数次，其他所有门到达偶数次
- 这和第一次到达p[i-1]门的情况完全相同，所以从p[i-1]门回到i-1门，需要dp[i-1]-dp[p[i-1]]
- 所以dp[i] = dp[i-1] + dp[i-1] - dp[p[i-1]] + 1 + 1
- dp[i] = 2 * dp[i-1] - dp[p[i-1]] + 2

```js
let n = parseInt(readline());
let p = readline().split(' ').map(Number);
let dp = Array(n).fill(0); //dp[i]表示第一次到达i的步数为dp[i]
for(let i=1; i<=n; i++){
  dp[i] = ((2 * dp[i-1] % 1000000007 - dp[p[i-1] -1] + 1) + 1) % 1000000007;
}
console.log(dp[n])
```

#### ZJ16 数列的和

> 难度： 简单

```txt
题目描述
数列的定义如下：数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。

输入描述:
输入数据有多组，每组占一行，由两个整数n（n<10000）和m(m<1000)组成，n和m的含义如前所述。

输出描述:
对于每组输入数据，输出该数列的和，每个测试实例占一行，要求精度保留2位小数。

示例1

输入
81 4
2 2

输出
94.73
3.41
```

```js
while(line = readline()) {
  let [n, m] = line.split(' ').map(Number);
  let sum = 0;
  for(let i=0; i<m; i++) {
    sum += n
    n = Math.sqrt(n);
  }
  print(sum.toFixed(2))
}
```

#### ZJ17 水仙花数

```txt
题目描述
春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的：“水仙花数”是指一个三位数，
它的各位数字的立方和等于其本身，比如：153=1^3+5^3+3^3。 现在要求输出所有在m和n范围内的水仙花数。

输入描述:
输入数据有多组，每组占一行，包括两个整数m和n（100<=m<=n<=999）。

输出描述:
对于每个测试实例，要求输出所有在给定范围内的水仙花数，就是说，输出的水仙花数必须大于等于m,并且小于等于n，
如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;如果给定的范围内不存在水仙花数，则输出no;每个测试实例的输出占一行。

示例1

输入
100 120
300 380

输出
no
370 371
```

```js
while(line = readline()) {
  let [m, n] = line.split(' ').map(Number);
  let res = [];
  for (let num=m; num<=n; num++) {
    // 下面三个都必须加parseInt强转，不知道什么原因，知道的朋友可以在GitHub的Issues里告知我一下
    let bai = parseInt(num / 100);
    let shi = parseInt(num % 100 / 10);
    let ge = parseInt(num % 100 % 10);
    let sum = bai ** 3 + shi ** 3 + ge ** 3;
    if (sum === num){
      res.push(num);
    }
  }
  if(res.length){
    console.log(res.join(' '));
  }else{
    console.log('no');
  }
}
```
