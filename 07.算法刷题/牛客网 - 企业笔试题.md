# 牛客网历年企业笔试题

## 字节跳动

### 字节跳动2018校招前端方向（第二批） [传送门](https://www.nowcoder.com/test/8537237/summary)

#### 用户喜好

```txt
为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1<=L2<=R2<=R1)。

输入描述：
输入： 第1行为n代表用户的个数 第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度 第3行为一个正整数q代表查询的组数  第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l<=i<=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n <= 300000,q<=300000 k是整型

输出描述:
输出：一共q行，每行一个整数代表喜好值为k的用户的个数

示例：

输入：
5
1 2 3 3 5
3
1 2 1
2 4 5
3 5 3

输出：
1
0
2

说明：
样例解释:
有5个用户，喜好值为分别为1、2、3、3、5，
第一组询问对于标号[1,2]的用户喜好值为1的用户的个数是1
第二组询问对于标号[2,4]的用户喜好值为5的用户的个数是0
第三组询问对于标号[3,5]的用户喜好值为3的用户的个数是2
```

```js
let n = parseInt(readline());
let arr = readline().split(' ').map(e => Number(e));
let q = parseInt(readline());
let xihaodu = [];
while(q>0){
  q--;
  xihaodu.push(readline().split(' ').map(e => Number(e)));
}
let res = [];
arr.forEach((item, index) => {
    if (res[item] == undefined){
        res[item]=[];
    }
    res[item].push(index);
})
xihaodu.forEach((item, index) => {
    let [l, r, k] = item;
    let count = 0;
    if (res[k] == undefined) {
        console.log(0)
    }else {
        res[k].forEach(e => {
            if (e>=l-1 && e<=r-1) {
                count++;
            }
        })
        print(count)
    }
})
```

#### 手串

```txt
作为一个手串艺人，有金主向你订购了一条包含n个杂色串珠的手串——每个串珠要么无色，要么涂了若干种颜色。为了使手串的色彩看起来不那么单调，金主要求，手串上的任意一种颜色（不包含无色），在任意连续的m个串珠里至多出现一次（注意这里手串是一个环形）。手串上的颜色一共有c种。现在按顺时针序告诉你n个串珠的手串上，每个串珠用所包含的颜色分别有哪些。请你判断该手串上有多少种颜色不符合要求。即询问有多少种颜色在任意连续m个串珠中出现了至少两次。

输入描述:
第一行输入n，m，c三个数，用空格隔开。(1 <= n <= 10000, 1 <= m <= 1000, 1 <= c <= 50) 接下来n行每行的第一个数num_i(0 <= num_i <= c)表示第i颗珠子有多少种颜色。接下来依次读入num_i个数字，每个数字x表示第i颗柱子上包含第x种颜色(1 <= x <= c)

输出描述:
一个非负整数，表示该手链上有多少种颜色不符需求。

示例1‘

输入
5 2 3
3 1 2 3
0
2 2 3
1 2
1 3

输出
2

说明
第一种颜色出现在第1颗串珠，与规则无冲突。
第二种颜色分别出现在第 1，3，4颗串珠，第3颗与第4颗串珠相邻，所以不合要求。
第三种颜色分别出现在第1，3，5颗串珠，第5颗串珠的下一个是第1颗，所以不合要求。
总计有2种颜色的分布是有问题的。
这里第2颗串珠是透明的。
```

```js
let [n, m, c] = readline().trim().split(' ').map(e => parseInt(e));
let arr = [];
for (let i=0;i<n;i++){
  arr.push(readline().split(' ').map(e => parseInt(e)));
}
let res = [];
arr.forEach((item, index) => {
  if (item[0] > 0) {
    item.slice(1).forEach(e => {
      if(res[e]) {
        res[e].push(index+1);
      }else {
        res[e] = [index + 1];
      }
    })
  }
})
let count = 0;
res.forEach(item => {
  for(let i=0;i<item.length-1;i++){
    if(item[i+1]-item[i]<m){
      count++
      break;
    }
    if(item[0]-item[item.length-1]+n<m){ //因为手链是个环，所以最后一个要跟第一个做一下比较
      count++;
      break;
    }
  }
})
print(count)
```
